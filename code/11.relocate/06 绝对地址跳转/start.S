
.text
.global _start

_start:
/*=======================================================================================*/

	/* 关闭看门狗 */
	ldr r0, =0x53000000
	mov r1, #0
	str r1,[r0]
	
/*=======================================================================================*/	

	/* 设置MPLL,使得FLCK:HCLK:PCLK = 400M : 100M : 50M */
	/* LOCKTIME(0x4C000000) = 0xFFFFFFFF*/
	ldr r0, =0x4C000000
	ldr r1, =0xFFFFFFFF
	str r1,[r0]
	
	/* CLKDIVN(0x4C000014) = 0x05,fFCLK:fHCLK:fPCLK = 8:4:1 */
	ldr r0, =0x4C000014
	mov r1, #0x05
	str r1,[r0]
	
	/* 设置CPU工作异步模式[数据手册提供] */
	mrc p15,0,r0,c1,c0,0   //c:co-process 协处理器
	orr r0,r0,#0xc0000000  //#R1_nF:OR:R1_iA
	mcr p15,0,r0,c1,c0,0  
	
	/* 设置MPLLCON(0x4C000004) = (92<<12) | (1<<4) | (1<<0)
	 * m = MDIV+8 = 92+8 =100
	 * p = PDIV+2 = 1+2 =3
	 * s = SDIV = 1
	 * FLCK = (2*m*Fin)/(p*(2^s)) = (2*100*12M)/(3*2^1) = 400M
 	 */
	ldr r0, =0x4C000004
	ldr r1, =(92<<12) | (1<<4) | (1<<0)
	str r1,[r0]
	
	//一旦设置PLL,就会锁定LOCK TIME直到PLL输出稳定,然后CPU工作
	
/*=======================================================================================*/	

	/* 
	 * 分辨是nor/nand启动
	 * 方法：写0到0地址，在读取出来，如果得到0，表示0地址上的内容被修改，即为片内RAM，则为nand启动(可修改)
	 * 否则是nor启动
	 * 原因：nor不能直接写入，写入需要发出一定格式的数据，才能写入
 	*/
	mov r0,#0 
	ldr r1,[r0]  			  //读出[0]上的值备份在r1中
	str r0,[r0]  			  //把0写入[0]
	ldr r2,[r0]  			  //从[0]读取到的值放入r2
	cmp r0, r2   			  //r2是否等于0
	ldr sp, =0x40000000+4096  //先假设nor启动
	moveq sp, #4096           //相等则为nand 启动,设置栈
	streq r1,[r0] 			  //相等则恢复[0]的值
	
/*=======================================================================================*/
	
	bl sdram_init  //初始化sdram

	/* 重定位text、rodata、data段 */
	mov r1, #0   //data段在bin文件中的地址,通过lds文件中的宏LOADADDR(.data)获得
	ldr r2, =_start      //第一条指令运行时地址,即lds中指定的0x30000000
	ldr r3, =__bss_start //bss段起始地址
cpy:
	ldr r4, [r1]
	str r4, [r2]  //将除bss段的数据全部复制到到sdram
	add r1,r1,#4
	add r2,r2,#4
	cmp r2,r3     //是否达到结束地址
	ble cpy       //小于或相等则继续拷贝

/*=======================================================================================*/

	/* 清零bss段 */
	ldr r1, =__bss_start //获取bss段起始地址
	ldr r2, =__bss_end   //bss段结束地址
	mov r3,#0 

clean:
	str r3,[r1]  //清零
	add r1,r1,#4 //地址+4
	cmp r1,r2    //是否达到结束地址
	ble clean    //小于或相等继续清零

/*=======================================================================================*/	
	
	//bl main //使用BL命令为相对跳转,程序仍然在nor/片内sram中运行

	ldr pc, =main //绝对跳转,跳转到SDRAM
	
halt:
	b halt





