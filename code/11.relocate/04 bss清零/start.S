
.text
.global _start

_start:
/*=======================================================================================*/

	/* 关闭看门狗 */
	ldr r0, =0x53000000
	mov r1, #0
	str r1,[r0]
	
/*=======================================================================================*/	

	/* 设置MPLL,使得FLCK:HCLK:PCLK = 400M : 100M : 50M */
	/* LOCKTIME(0x4C000000) = 0xFFFFFFFF*/
	ldr r0, =0x4C000000
	ldr r1, =0xFFFFFFFF
	str r1,[r0]
	
	/* CLKDIVN(0x4C000014) = 0x05,fFCLK:fHCLK:fPCLK = 8:4:1 */
	ldr r0, =0x4C000014
	mov r1, #0x05
	str r1,[r0]
	
	/* 设置CPU工作异步模式[数据手册提供] */
	mrc p15,0,r0,c1,c0,0   //c:co-process 协处理器
	orr r0,r0,#0xc0000000  //#R1_nF:OR:R1_iA
	mcr p15,0,r0,c1,c0,0  
	
	/* 设置MPLLCON(0x4C000004) = (92<<12) | (1<<4) | (1<<0)
	 * m = MDIV+8 = 92+8 =100
	 * p = PDIV+2 = 1+2 =3
	 * s = SDIV = 1
	 * FLCK = (2*m*Fin)/(p*(2^s)) = (2*100*12M)/(3*2^1) = 400M
 	 */
	ldr r0, =0x4C000004
	ldr r1, =(92<<12) | (1<<4) | (1<<0)
	str r1,[r0]
	
	//一旦设置PLL,就会锁定LOCK TIME直到PLL输出稳定,然后CPU工作
	
/*=======================================================================================*/	

	/* 
	 * 分辨是nor/nand启动
	 * 方法：写0到0地址，在读取出来，如果得到0，表示0地址上的内容被修改，即为片内RAM，则为nand启动(可修改)
	 * 否则是nor启动
	 * 原因：nor不能直接写入，写入需要发出一定格式的数据，才能写入
 	*/
	mov r0,#0 
	ldr r1,[r0]  			  //读出[0]上的值备份在r1中
	str r0,[r0]  			  //把0写入[0]
	ldr r2,[r0]  			  //从[0]读取到的值放入r2
	cmp r0, r2   			  //r2是否等于0
	ldr sp, =0x40000000+4096  //先假设nor启动
	moveq sp, #4096           //相等则为nand 启动,设置栈
	streq r1,[r0] 			  //相等则恢复[0]的值
	
/*=======================================================================================*/
	
	bl sdram_init  //初始化sdram

	/* 重定位data端 */
	ldr r1, =data_load_addr //data段在bin文件中的地址,通过lds文件中的宏LOADADDR(.data)获得
	ldr r2, =data_start     //data段在重定位的地址,运行时的地址
	ldr r3, =data_end       //data段结束地址
cpy:
	ldrb r4, [r1]
	strb r4, [r2] //将全局变量复制到sdram
	add r1,r1,#1
	add r2,r2,#1
	cmp r2,r3     //是否达到结束地址
	bne cpy       //不相等则继续拷贝

/*=======================================================================================*/

	/* 清零bss段 */
	ldr r1, =bss_start //获取bss段起始地址
	ldr r2, =bss_end   //bss段结束地址
	mov r3,#0 

clean:
	strb r3,[r1]  //清零
	add r1,r1,#1 //地址+1
	cmp r1,r2    //是否达到结束地址
	bne clean//不相等继续清零

/*=======================================================================================*/	

	bl main 
	
halt:
	b halt





