# 1.学习汇编基础指令

- `LDR`：（Load）读内存
    - `LDR R0,[R1]`，假设R1地址为x，则读取x上的数据（4个字节），保存在R0中

- LDR r0,=label //用于加载立即数或一个地址值到指定寄存
例如:
- LDR r0,[r1]      //将R1中的值存到r0中
- LDR r1,[r2,#16] //将(r2+16)地址中的内容存到r1中
- LDR r1,[r2],#4  //将r2地址中的内容存到r1中,同时r2=r2+4

---
- `STR`：（Store）写内存
    - `STR R0,[R1]`，假设R1的值为x，把R0的值写到地址x中去（4字节）

- STR R1, [R0]         //将r1寄存器的值，传送到地址值为r0的（存储器）内存中
- STR R0，[R1,＃8]   //将R0中的字数据写入以R1＋8为地址的存储器中
- STR R0，[R1]＃8 //将R0中的字数据写入以R1为地址的存储器中，并将新地址R1＋8写入R1


---
- `B`：(branch) 跳转/分支
---
- `BL`：(branch and link) 跳转并链接
    - 跳转到xxx，并把返回地址（下一条指令的地址）保存在`LR`寄存器中
---
- `MOV`：（Move）
    - `MOV R0,R1`，把R1的值赋给R0
    - `MOV R0,#0x100`：R0 = 0x100
---
- `LDR R0,=0x12345678`：（伪指令（多一个=），可以拆分为多条ARM指令）R0 = 0x12345678
    - 为什么不用`MOV R0,#0x12345678`给R0赋值，而用伪指令？
    - 答：一条ARM指令32位，其中有几位表示MOV指令本身，其中一位表示R0，则剩余的位数不足以保存任意值，只能表示简单值（即**立即数**）